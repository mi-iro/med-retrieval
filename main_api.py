import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import Optional
import json

# 从我们准备好的模块中导入核心功能
from query_generator import generate_queries_for_question
from retriever import Retriever

# --- FastAPI应用初始化 ---
app = FastAPI(
    title="Intelligent Query Processing Service (Dynamic Parameters)",
    description="A service that accepts a user question with dynamic 'topk' and 'n_queries' parameters, generates targeted sub-queries, retrieves relevant documents, and returns the consolidated results.",
    version="2.0.0",
)

# --- 定义API的请求和响应模型（已更新） ---
class QueryRequest(BaseModel):
    question: str = Field(
        ..., 
        min_length=10,
        example="Proof of concept study: does fenofibrate have a role in sleep apnoea syndrome?"
    )
    topk: Optional[int] = Field(
        default=10, 
        gt=0, 
        le=50, 
        description="The number of documents to retrieve for each query."
    )
    n_queries: Optional[int] = Field(
        default=3, 
        gt=0, 
        le=5, 
        description="The maximum number of queries to generate for each data source."
    )

class ApiResponse(BaseModel):
    parameters_used: dict = Field(..., description="The parameters (topk, n_queries) used for this request.")
    generated_queries: list = Field(..., description="The list of structured queries generated by the LLM.")
    retrieved_documents: list = Field(..., description="The list of documents retrieved based on the generated queries.")


# --- API 端点定义（已更新） ---
@app.post("/process-query/", response_model=ApiResponse)
async def process_query_endpoint(request: QueryRequest):
    """
    接收一个用户问题及可选参数，执行两步流程：
    1.  **生成查询**: 将问题发送给大语言模型，以创建一组针对不同数据源的结构化查询。可使用 `n_queries` 参数控制数量。
    2.  **检索文档**: 使用上一步生成的查询来从各个数据源检索相关文档。可使用 `topk` 参数控制数量。
    
    最后，将生成的查询和检索到的文档作为响应返回。
    """
    try:
        # 步骤 1: 调用查询生成模块，传入动态的 n_queries 参数
        print(f"Generating up to {request.n_queries} queries per source for question: \"{request.question}\"")
        source_and_queries = generate_queries_for_question(request.question, n_queries=request.n_queries)
        print("Generated queries successfully:")
        print(json.dumps(source_and_queries, indent=2))

        # 步骤 2: 根据动态的 topk 参数在请求时创建 Retriever 实例并调用
        print(f"Retrieving top {request.topk} documents with generated queries...")
        retriever_instance = Retriever(topk=request.topk)
        retrieved_docs = retriever_instance.run(source_and_queries)
        print("Documents retrieved successfully.")

        # 步骤 3: 构造并返回成功的响应，包含本次请求使用的参数
        return {
            "parameters_used": {
                "topk": request.topk,
                "n_queries": request.n_queries
            },
            "generated_queries": source_and_queries,
            "retrieved_documents": retrieved_docs
        }

    except ValueError as e:
        print(f"An error occurred during retrieval: {e}")
        raise HTTPException(status_code=500, detail=f"An error occurred during the retrieval process: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        raise HTTPException(status_code=500, detail=f"An unexpected server error occurred: {e}")

@app.get("/", summary="Health Check")
def read_root():
    """
    提供一个简单的端点，用于检查服务是否正在运行。
    """
    return {"status": "ok", "message": "Query Processing Service is running."}

# --- 运行服务器 ---
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)