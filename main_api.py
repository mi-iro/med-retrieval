import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import Optional, List, Dict
import json
import numpy as np
import sys

# 从我们准备好的模块中导入核心功能
from query_generator import generate_queries_for_question
from retriever import Retriever

# --- FastAPI应用初始化 ---
app = FastAPI(
    title="Intelligent Query Processing Service (Dynamic Parameters)",
    description="A service that accepts a user question with dynamic 'topk' and 'n_queries' parameters, generates targeted sub-queries, retrieves relevant documents, and returns the consolidated results with performance metrics.",
    version="2.1.0",
)

# --- 定义API的请求和响应模型（已更新） ---
class QueryRequest(BaseModel):
    question: str = Field(
        ..., 
        min_length=10,
        example="Proof of concept study: does fenofibrate have a role in sleep apnoea syndrome?"
    )
    topk: Optional[int] = Field(
        default=10, 
        gt=0, 
        le=50, 
        description="The number of documents to retrieve for each query."
    )
    n_queries: Optional[int] = Field(
        default=3, 
        gt=0, 
        le=5, 
        description="The maximum number of queries to generate for each data source."
    )

class PerformanceMetrics(BaseModel):
    query_planning_seconds: float = Field(..., description="Time taken for the query generation phase.")
    retrieval_seconds: float = Field(..., description="Time taken for the document retrieval phase.")
    rerank_seconds: float = Field(..., description="Time taken for the document reranking phase.")
    average_rerank_score: Optional[float] = Field(None, description="The average rerank score of all retrieved documents.")

class ApiResponse(BaseModel):
    parameters_used: dict = Field(..., description="The parameters (topk, n_queries) used for this request.")
    performance_metrics: PerformanceMetrics = Field(..., description="Performance metrics for the request.")
    generated_queries: list = Field(..., description="The list of structured queries generated by the LLM.")
    retrieved_documents: list = Field(..., description="The list of documents retrieved based on the generated queries.")


# --- API 端点定义（已更新） ---
@app.post("/process-query/", response_model=ApiResponse)
async def process_query_endpoint(request: QueryRequest):
    """
    接收一个用户问题及可选参数，执行两步流程，并返回详细的性能指标：
    1.  **生成查询**: 将问题发送给大语言模型，创建结构化查询。
    2.  **检索与重排**: 使用生成的查询检索并重排文档。
    
    返回内容包括生成的查询、检索到的文档，以及各阶段耗时和平均重排分数。
    """
    try:
        # 步骤 1: 调用查询生成模块，并计时
        print(f"Generating up to {request.n_queries} queries per source for question: \"{request.question}\"")
        source_and_queries, planning_time = generate_queries_for_question(request.question, n_queries=request.n_queries)
        print(f"Generated queries successfully in {planning_time:.4f} seconds:")
        print(json.dumps(source_and_queries, indent=2))

        # 步骤 2: 创建Retriever实例并调用，获取文档和计时信息
        print(f"Retrieving top {request.topk} documents with generated queries...")
        retriever_instance = Retriever(topk=request.topk)
        retrieved_docs, search_timing = retriever_instance.run(source_and_queries)
        print("Documents retrieved successfully.")

        # 步骤 3: 计算平均 rerank_score
        all_scores = []
        for doc_group in retrieved_docs:
            if 'results' in doc_group:
                for doc in doc_group['results']:
                    if 'rerank_score' in doc:
                        all_scores.append(doc['rerank_score'])
        
        avg_rerank_score = np.mean(all_scores) if all_scores else None

        # 步骤 4: 构造并返回成功的响应
        return {
            "parameters_used": {
                "topk": request.topk,
                "n_queries": request.n_queries
            },
            "performance_metrics": {
                "query_planning_seconds": planning_time,
                "retrieval_seconds": search_timing.get("retrieval_time_seconds", 0),
                "rerank_seconds": search_timing.get("rerank_time_seconds", 0),
                "average_rerank_score": avg_rerank_score
            },
            "generated_queries": source_and_queries,
            "retrieved_documents": retrieved_docs
        }

    except ValueError as e:
        print(f"An error occurred during retrieval: {e}")
        raise HTTPException(status_code=500, detail=f"An error occurred during the retrieval process: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        raise HTTPException(status_code=500, detail=f"An unexpected server error occurred: {e}")

@app.get("/", summary="Health Check")
def read_root():
    """
    提供一个简单的端点，用于检查服务是否正在运行。
    """
    return {"status": "ok", "message": "Query Processing Service is running."}

# --- 运行服务器 ---
if __name__ == "__main__":
    assert len(sys.argv) > 1, "PORT?"
    port = int(sys.argv[1])
    uvicorn.run(app, host="0.0.0.0", port=port)